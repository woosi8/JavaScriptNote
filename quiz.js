2. What's the output?
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

Since the variable i in the first loop was declared using the var keyword, this value was global.
During the loop, we incremented the value of i by 1 each time, using the unary operator ++. By the time the setTimeout callback function was invoked,
i was equal to 3 in the first example.

In the second loop, the variable i was declared using the let keyword: variables declared with the let (and const) keyword are block-scoped (a block is anything between { }).
During each iteration, i will have a new value, and each value is scoped inside the loop.



Answer = C: 3 3 3 and 0 1 2

7.
new Number() is a built-in function constructor.
When we use the == operator, it only checks whether it has the same value. They both have the value of 3, so it returns true.
However, when we use the === operator, both value and type should be the same. It's not: new Number() is not a number, it's an object. Both return false.


18.
This is why both { age: 18 } === { age: 18 } and { age: 18 } == { age: 18 } return false.
JavaScript checks if the objects have a reference to the same location in memory.

20.
With "use strict", you can make sure that you don't accidentally declare global variables. 

24.
All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. 


28. What's the output?
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

name.giveLydiaPizza();

A: "Just give Lydia pizza already!"
String is a built-in constructor, which we can add properties to. I just added a method to its prototype. 
Primitive strings are automatically converted into a string object, generated by the string prototype function.
 So, all strings (string objects) have access to that method!


40.
 const red = [[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2],
);
console.log(red);

46.
let person = { name: 'Lydia' };
const members = [person];
person = null;

console.log(members);
When you assign a reference from one variable to another,
you make a copy of that reference. (note that they don't have the same reference!)

51.???
82.???
var koGreeting = { 
  greeting : "ì•ˆë…•",
  name : "í™ê¸¸ë™", 
  sayHello: function() { 
    return this.greeting + ", " + this.name; } 
  }; 
var enGreeting = { 
    greeting: "Hello",
    name: "HongKilDong" 
  };

  console.log(koGreeting.sayHello()); 
  console.log(koGreeting.sayHello.call(enGreeting)); 
  ê²°ê³¼) ì•ˆë…•, í™ê¸¸ë™ 
        Hello, Hong KilDong


100. What's the value of output?
// ðŸŽ‰âœ¨ This is my 100th question! âœ¨ðŸŽ‰

const output = `${[] && 'Im'}possible!
You should${'' && `n't`} see a therapist after so much JavaScript lol`;
console.log(output)

[] is a truthy value.
"" is a falsy value. 


108. Which of these methods modifies the original array?
const emojis = ['âœ¨', 'ðŸ¥‘', 'ðŸ˜'];

emojis.map(x => x + 'âœ¨');   // return a new array
emojis.filter(x => x !== 'ðŸ¥‘');  // return a new array : return an array with true values
emojis.find(x => x !== 'ðŸ¥‘');  // returns an element : í•´ë‹¹í•˜ëŠ” ì²«ë²ˆì§¸ ê°’ë§Œ ì°¾ëŠ”ë‹¤ when the function return true, and end. 
emojis.reduce((acc, cur) => acc + 'âœ¨'); // returns a reduced value.
emojis.slice(1, 2, 'âœ¨');  // ì¶”ì¶œ (index1ë¶€í„° 2ì „ê¹Œì§€(2ëŠ” í¬í•¨ì•ˆë¨)) it dosen't affect the original array = return a new array
emojis.splice(1, 2, 'âœ¨'); // ì¶”ì¶œ ì‚½ìž… (index1 ë¶€í„° 2ê¹Œì§€ ì„ íƒ) remove 2 items from index 1 and add the âœ¨ emoji instead. : has an effect on the original array 


// set,get
115. Which method(s) will return the value 'Hello world!'?
const myMap = new Map();
const myFunc = () => 'greeting'; //key
          //key     value
myMap.set(myFunc, 'Hello world!');

//1
myMap.get('greeting');
//2
myMap.get(myFunc);
//3
myMap.get(() => 'greeting');

// answer : 2
When adding a key/value pair using the set method, the key will be the value of the first argument passed to the set function,
and the value will be the second argument passed to the set function. 
The key is the function () => 'greeting' in this case, and the value 'Hello world'. myMap is now { () => 'greeting' => 'Hello world!' }.

// change an array to number
// we can spread iterables to individual elements.
117. Which of the following options will return 6?
function sumValues(x, y, z) {
  return x + y + z;
}
sumValues(...[1, 2, 3]);